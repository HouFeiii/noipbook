
## 迷宫问题引入


### [问题描述]

![1](./迷宫1.png)

你是一个善良的男孩Butter,有一天你被邪恶的巫师Cartman抓到了**黑暗迷宫**,黑暗迷宫的魔法可以让所有进入的人失明.迷宫中**黑色**的格子是**诅咒陷阱**,进入就会死亡(迷宫的外围是火海),白色的格子是安全的格子.

在你一无所措的时候,有一个善良机器人**AWRSOM-O**向你发信息.它可以告诉你所在的格子的**上下左右**的四个格子是哪种格子,而且还可以告诉你某个格子是不是以前走过了.

问你能走出迷宫吗?如果能就输出:**YES**,不能输出:**NO**


### [输入样列]

### [输出样列]

## 解析


**cgdb**调试一遍看看

## 代码

```c
#include <cstdio>

#define ms 5 //迷宫大小

int rms =ms-1; // rms = real mi gong size
int zx = ms-1,zy=ms-1; //zx,zy 终点坐标
int fx[4][2] = {  {-1,0},{0,1},{1,0},{0,-1}};
bool visted[ms][ms] = {0};

char mg[ms][ms] = {
    0,0,0,0,0,
    0,0,0,1,0,
    0,1,0,0,0,
    0,1,1,1,0,
    0,1,1,1,0
};

bool in_mg(int x,int y){
    if(x <= rms && x>=1 && y <=rms && y >=1)
        return true;
    return false;
}

//调用了 zou_mi_gong 相当于进入了x,y这个点
bool zou_mi_gong(int x,int y){

    visted[x][y] =1; //设这个点走过
    if(x == zx && y == zy) //表示已经到了终点
        return true;

    int i;
    for(i=0;i<4;i++){
        
        int tx = x+fx[i][0];
        int ty = y+fx[i][1]; //tx,ty 下一个格子的坐标

        //判断tx,ty 是不是可以走的格子
        if( in_mg(tx,ty) && mg[tx][ty]!=1 && visted[tx][ty] !=1){ 
            if( zou_mi_gong(tx,ty) == true)
                return true;//只要返回true 这层函数就结束了
                            // 上层函数也会接着返回true
                            // 整个递归就会不停的回溯
        }

    }
    return false;
}

int main(){
    if( zou_mi_gong(1,1))
        printf("yes! ni huo le!");
    else
        printf("no! you died!");
    return 0;
}
```
