

## 问题引入

假如我们有一段区间[1,n],我们每一次要替换区间[x,y]为一个固定值c,也会不停的查询某段区间的和?怎么做最快呢?

数据1:

```
5
1 2 3 4 5
4
c 1 3 8
q 1 3
c 1 2 5
q 1 4
```

用上面的单点更新,也可以解决这个问题.但是,当m非常大的时候,我们更新的次数太多了.

想一想:因为每一次更新一个区间,我们不需要把所有的叶子节点都更新,也就是不需要更新到叶子节点.**我们只需要更新到能把这段区间覆盖的节点**就行了.

我们把这个节点设一个**标记**,表明:这个节点有一个被更新了,下次**路过**这个节点的时候,发现了这个**标记**,那就把这个结点:**向下更新**(因为路过这个结点,有可能访问更下面的结点,那就把这个点的标记值往下放)


 路过的情况:
 
 - query一个在标记结点下面的结点
 - 更新一个在标记结点下面的结点
 
当然不同的题目,有不同我们有不同的pushdown,update,query的写法


![1](/images/线段树区间更新.gif)

那我给上面的单点更新添加两个操作:

操作1: pushdown 把flag 树的值向下push,并且更新st[lson],st[rson]的值

```c
void pushdown(int rt,int m){
	if( flag[rt]){ //如果flag的rt点有值
		/* 向下更新 */
		flag[lson(rt)] = flag[rson[rt]] = flag[rt];
		/* 更新左孩子*/
		st[lson(rt)] = flag[rt] *(m-m(m>>1));
		/* 更新右孩子*/
		st[rson(rt)] = flag[rt] *(m>>1);
		flag[rt] = 0;/* 自己清空 */
	}
}
```

操作2: update 更新一段区间,当然要用到lazy方法

```
void update(int l1,int r1,int c,int l,int r,int rt){
	if(l1 <= l && r <= r1 ){ //到了能覆盖区间的的结点
		flag[rt] = c;        //留下标记
		st[rt] = (r-l+1)*c;  //更新当前ST结点的值
		return ;
	}
	pushdown(rt,r-l+1);
	int m = (l+r) >>1;
	if( l1 <=m) update(l1,r1,c,l,m,lson(rt));
	if( r1 > m) update(l1,r1,c,m+1,r,rson(rt));
	pushup(rt);
}
```

修改query操作

操作3: query 和单点更新的query 差不多,但是我们要注意,query也会路过flag点

```
int query(int l1,int r1,int l,int r,int rt){
	if(l1<= l && r<=r1){
		return st[rt];
	}
	pushdown(rt);
	int m =(l+r)>>1;
	int ret = 0;
	if(l <=m) ret+=query(l1,r1,l,m,lson(rt));
	if(r >m ) ret +=query(l1,r1,m+1,r,rson(rt));
	return ret;
}	
```


整体代码:

```c
/*============================================================================
* Title : 线段树 成段替换
* Author: Rainboy
* Time  : 2016-05-27 13:05
* update: 2016-05-27 13:05
* ? Copyright 2016 Rainboy. All Rights Reserved.
*=============================================================================*/

#include <cstdio>
#include <cstring>

const int maxn = 1000;

int st[maxn<<2];
int flag[maxn<<2];

#define lson(rt) (rt<<1)
#define rson(rt) ((rt<<1)|1)

int n,m;

void pushup(int rt){
    st[rt] = st[lson(rt)] + st[rson(rt)];
}

void pushdown(int rt,int m){
    if(flag[rt]){
        flag[lson(rt)] = flag[rson(rt)] = flag[rt];
        st[lson(rt)] = flag[rt]*(m-(m>>1));
        st[rson(rt)] = flag[rt]*(m>>1);
        flag[rt] = 0;
    }
}

void update(int l1,int r1,int c,int l,int r,int rt){
    if(l1 <=l && r<=r1){
        flag[rt] = c; //我们到达一个点
        st[rt] = (r-l+1)*c;
        return ;
    }
    pushdown(rt,(r-l+1));
    int m = (l+r)>>1;
    if( l1 <= m) update(l1,r1,c,l,m,lson(rt));
    if( r1 > m) update(l1,r1,c,m+1,r,rson(rt));
    pushup(rt);

}

int query(int l1,int r1,int l,int r,int rt){
    if(l1<=l && r <= r1){
        return st[rt];
    }
    pushdown(rt,(r-l+1));
    int ret = 0;
    int m = (l+r)>>1;
    if(l1 <= m) ret+= query(l1,r1,l,m,lson(rt));
    if(r1 > m ) ret+= query(l1,r1,m+1,r,rson(rt));
    return ret;
}

void build(int l,int r,int rt){
    if( l==r){
        scanf("%d",&st[rt]);
		return ;
    }
    int m = (l+r)>>1;
    build(l,m,lson(rt));
    build(m+1,r,rson(rt));
    pushup(rt);
}

int main(){
    memset(flag,0,sizeof(flag));
    scanf("%d",&n);
    build(1,n,1);
    scanf("%d",&m);
    
    int i,j,k;
    char c;
    while(m--){
        scanf("%c",&c); //读两次,滤掉\n
		scanf("%c",&c);
        if( c == 'c' ){
            scanf("%d%d%d",&i,&j,&k);
			update(i,j,k,1,n,1);
        }else {
            scanf("%d%d",&i,&j);
			int ans = query(i,j,1,n,1);
			printf("%d\n",ans);
        }
    }
    return 0;
}

```

数据生成+对拍程序

https://yunpan.cn/cSESkjm538AfK （提取码：fdbb）

## 加深自己的理解

 1. 用纸和笔把数据1和整个过程模拟出来
 2. 把下面的数据,用纸和笔把整个过程模拟出来
 
数据2: 相加

数据3: 相减


## 相关练习题目

 - hud1698 just a hook
 - poj3468 A simple problem with integers
 - cojs 2319 地球往事 (http://cojs.tk/cogs/problem/problem.php?pid=2319)


